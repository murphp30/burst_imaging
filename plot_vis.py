#!/usr/bin/env python
"""
Visibility fitting script used in Murphy et al. 2020.

Input is a numpy save file generated by vis_to_npy.py
"""

import argparse
import sys
sys.path.insert(1,'/mnt/LOFAR-PSP/pearse_2ndperihelion/scripts')
sys.path.insert(1,'/Users/murphp30/mnt/LOFAR-PSP/pearse_2ndperihelion/scripts')

from multiprocessing import Pool
 
import corner
import emcee
import time
import pdb

import astropy.units as u
import matplotlib.colorbar as colorbar
import matplotlib.pyplot as plt
plt.style.use('seaborn-colorblind')
import matplotlib.patheffects as path_effects
import numpy as np
import pandas as pd

from astropy.constants import au, e, eps0, c, m_e, R_sun
from astropy.coordinates import Angle, SkyCoord
from astropy.time import Time, TimeDelta
from casacore import tables
from lmfit import Minimizer, minimize, Model, Parameters 
from matplotlib import dates
from matplotlib.gridspec import GridSpec
from matplotlib.patches import Circle, Ellipse
from mpl_toolkits.axes_grid1 import make_axes_locatable
from mpl_toolkits.mplot3d import Axes3D
from sunpy.time import TimeRange


def FWHM(sig):
    fwhm = (2*np.sqrt(2*np.log(2))*sig)
    fwhm = Angle(fwhm*u.rad).arcmin
    return fwhm

def FWHM_to_sig(FWHM):
    c = FWHM/(2*np.sqrt(2*np.log(2)))
    return c

def rotate_coords(u,v, theta):
    # rotate coordinates u v  anticlockwise by theta
    u_p =  u*np.cos(theta) + v*np.sin(theta)
    v_p = -u*np.sin(theta) + v*np.cos(theta)
    return u_p, v_p

def gauss_2D(u,v,I0,x0,y0,sig_x,sig_y,theta,C):
    """
    gaussian is rotated, change coordinates to 
    find this angle
    """
    pa = -theta # gauss position angle becuase we're rotating the gaussian to align with our coordinates...or something,
                   # it doesn't work if you don't so that's reason enough...
    # pdb.set_trace()
    # x0 = -x0 # x,y = ra,dec increment in ra is negative so need to change y0 to negative, maybe?
    # y0 = -y0
    # x0, y0 = y0, -x0
    theta_rot = np.arctan(y0/x0)
    theta0 = pa - theta_rot
    u_p,v_p  =  rotate_coords(u,v,pa)
    u_r, v_r = rotate_coords(u,v,theta0)
    x0_p, y0_p = rotate_coords(x0,y0,pa)
    amp = I0/(2*np.pi)
    # shift = np.exp(-2*np.pi*1j*(u_r*y0_p-v_r*x0_p)) #no idea why it has to be done this way, sorry.
    shift = np.exp(-2*np.pi*1j*(u*y0 - v*x0)) 
    # pdb.set_trace()
    # V =  np.exp(-2*np.pi*1j*(u*x0+v*y0)) \
    # * (((I0/(2*np.pi)) * np.exp(-(((sig_x**2)*((2*np.pi*u_p)**2))/2) + (((sig_y**2)*((2*np.pi*v_p)**2))/2))) + C)
    V = shift * (amp * np.exp(-( (((sig_x**2)*(2*np.pi*u_p)**2)/2) + (((sig_y**2)*(2*np.pi*v_p)**2)/2) )) + C)

    return V



def nbaselines(nants):
    #calculate number of baselines including self correlations
    #given a number of antennas
    return nants*(nants+1)/2

class LOFAR_vis:
    """
    A class that contains a LOFAR measurment set 
    and the various ways it's split into useful things.
    Requires a npz file created with vis_to_npy.py
    and a time sample number/timestamp
    """

    def __init__(self, fname, trange):
        self.fname = fname
        self.trange = trange
        with tables.table(self.fname+'ANTENNA') as tant:
            self.nbaselines = nbaselines(tant.nrows())
        with tables.table(self.fname+'FIELD') as tfield:
            phase_dir = tfield.col('PHASE_DIR')[0][0]
            self.phase_dir = SkyCoord(*phase_dir*u.rad)
        with tables.table(self.fname+'SPECTRAL_WINDOW') as tspec:
            freq = tspec.col('REF_FREQUENCY')[0]*u.Hz
            self.wlen = (c/freq).decompose()
            self.freq = freq.to(u.MHz)
        self.__get_data()
        
    def __get_data(self):
        mjd0 = Time(0, format='mjd')
        mjds = self.trange.start - mjd0
        mjde = self.trange.end - mjd0
        mjds = mjds.sec
        mjde = mjde.sec
        with tables.table(self.fname) as t:
            self.dt = t.col('INTERVAL')[0] * u.s
            with tables.taql('select from $t where TIME > $mjds and TIME < $mjde') as t1:
                self.antenna1 = t1.getcol('ANTENNA1')
                self.antenna2 = t1.getcol('ANTENNA2')
                self.flag = t1.getcol('FLAG')
                cross_cors = np.where(self.antenna1 != self.antenna2)
                self.uvw = t1.getcol('UVW')[cross_cors]/self.wlen
                self.time = Time(t1.getcol('TIME',rowincr=int(self.nbaselines))/24/3600, format='mjd')
                self.data = np.median(t1.getcol('CORRECTED_DATA'), axis=1)[cross_cors]
                self.uncal = np.median(t1.getcol('DATA'), axis=1)[cross_cors]
                self.model = np.median(t1.getcol('MODEL_DATA'), axis=1)[cross_cors]
    def stokes(self, param):
        accepted_params = ['I', 'Q', 'U', 'V']
        if param not in accepted_params:
            print("Please choose one of: I, Q, U, V.")
            return
        if param == 'I':
            return self.data[:,0] + self.data[:,3]
        elif param == 'Q':
            return self.data[:,0] - self.data[:,3]
        elif param == 'U':
            return np.real(self.data[:,1] + self.data[:,2])
        elif param == 'V':
            return np.imag(self.data[:,1] - self.data[:,2])

    def plot(self):
        plt.scatter(self.uvw[:,0], self.uvw[:,1])
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('MS', help='Input measurement set.')
    parser.add_argument('--trange', dest='trange', nargs='+',
                        help='time range for observation.\
                        2 arguments START and END in format YYYY-MM-DDTHH:MM:SS\
                        if only START given then assume END is 1 second later.',
                        metavar=('START','END'))
    args = parser.parse_args()
    msin = args.MS
    trange = args.trange
    if len(trange) == 2:
        trange = TimeRange(trange[0], trange[1])#("2019-04-04T14:08:00", "2019-04-04T14:17:00")
    elif len(trange) == 1:
        tstart = Time(trange[0])
        trange = TimeRange(tstart, tstart+1*u.s)
    t0 = time.time()
    vis = LOFAR_vis(msin, trange)
    gauss0 = vis.model[:630,0] + vis.model[:630,3]
    uv_dist0 = np.sqrt(vis.uvw[:630,0]**2 + vis.uvw[:630,1]**2)
    us = np.arange(np.min(vis.uvw[:,0].value),np.max(vis.uvw[:,0].value), 10)
    vs = np.arange(np.min(vis.uvw[:,1].value),np.max(vis.uvw[:,1].value), 10)
    uu, vv = np.meshgrid(us, vs)
    sigx = FWHM_to_sig(Angle(150*u.arcsec))
    sigy = FWHM_to_sig(Angle(300*u.arcsec))
    x0 = Angle(100*u.arcsec)
    y0 = Angle(50*u.arcsec)
    fit_gauss0 = gauss_2D(uu,vv, np.abs(2*np.pi*gauss0.max()), x0.rad, y0.rad, sigx.rad, sigy.rad, Angle(30*u.deg).rad, 0)
    # fit_gauss1 = gauss_2D(uu,vv, 2*np.pi*gauss0.max(), x0.rad, y0.rad, sigx.rad, sigy.rad, Angle(60*u.deg).rad, 0)

    # fit_gauss0 = fit_gauss0.reshape(len(vs), len(us))
    dd0 = np.exp(-2*np.pi*1j*(uu*y0.rad-vv*x0.rad)) * (2*np.pi*np.abs(gauss0.max()))
    # phase0 = -2*np.pi*(uu*x0.rad - vv*y0.rad)
    # phase0 = np.mod(phase0, 2*np.pi) - np.pi
    # phase1 = -2*np.pi*(uu*x0.rad - vv*y0.rad) + np.pi
    # phase1 = np.mod(phase1, 2*np.pi) - np.pi

    # shift1 = np.exp(-2*np.pi*1j*(uu*y0.rad-vv*x0.rad)
    # fig, ax = plt.subplots(figsize=(13,7),nrows=1,ncols=2, sharey=True)
    # # plt.figure()
    # ax[0].scatter(vis.uvw[:630,0], vis.uvw[:630,1], c=np.abs(gauss0))
    # ax[0].imshow(np.abs(fit_gauss0), aspect='auto', origin='lower',extent=[us[0], us[-1], vs[0], vs[-1]])
    # ax[0].set_title("Absolute value (amplitude)")
    # ax[0].set_xlim([us[0],us[-1]])
    # ax[0].set_ylim([vs[0],vs[-1]])
    # # plt.savefig("modelfit_abs.png")
    # # plt.contour(us, vs,np.abs(fit_gauss0), levels=[0.5*np.max(np.abs(fit_gauss0))], colors='r')
    # # plt.figure()
    # ax[1].scatter(vis.uvw[:630,0], vis.uvw[:630,1], c=np.angle(gauss0), vmin=-np.pi, vmax=np.pi)
    # ax[1].imshow(np.angle(fit_gauss0), aspect='auto', origin='lower',extent=[us[0], us[-1], vs[0], vs[-1]], vmin=-np.pi, vmax=np.pi)
    # ax[1].set_title("Phase (position)")
    # ax[1].set_xlim([us[0],us[-1]])
    # ax[1].set_ylim([vs[0],vs[-1]])
    # plt.savefig("model_ddfit.png")

    # plt.figure()
    # plt.scatter(vis.uvw[:630,0], vis.uvw[:630,1], c=np.abs(gauss0))

    print("Time to run {}".format(time.time()-t0))
    plt.show()



